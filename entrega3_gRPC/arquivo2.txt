import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
import socket  # para criar o servidor TCP (abrir porta, aceitar conexões, mandar/receber dados).
import struct  # para empacotar/desempacotar inteiros em bytes (útil para enviar tamanhos de arquivos).
import os  # para manipulação de arquivos (criar, deletar arquivos temporários).
import threading  # para lidar com múltiplos clientes simultaneamente.
import uuid  # para gerar identificadores únicos para arquivos temporários.
from fpdf import FPDF  # biblioteca para criar arquivos PDF a partir de texto.

# Formatos de conversão suportados
SUPPORTED = {
    ("txt", "pdf")
}

# Diretório para armazenar os arquivos convertidos
OUTPUT_DIR = "conversoes_servidor"

# Lock para sincronização de acesso a recursos compartilhados
file_lock = threading.Lock()

# Contador de clientes conectados (para logging)
client_counter = 0
counter_lock = threading.Lock()

def txt_to_pdf(input_path, output_path):
    pdf = FPDF()
    pdf.set_auto_page_break(auto=True, margin=15)
    pdf.add_page()
    pdf.set_font("Arial", size=12)

    # Lê o .txt linha a linha e escreve no PDF
    # encoding='utf-8' funciona bem para textos com acentos
    with open(input_path, "r", encoding="utf-8", errors="ignore") as f:
        for line in f:
            # rstrip() tira quebras de linha pra não ficar linha em branco dupla
            pdf.multi_cell(0, 8, line.rstrip("\n"))

    pdf.output(output_path)


def convert_file(input_path, output_path, src, dst):
    """Realiza a conversão de arquivo conforme os formatos especificados."""
    if (src, dst) == ("txt", "pdf"):
        txt_to_pdf(input_path, output_path)
    else:
        raise ValueError(f"Conversão não suportada: {src} -> {dst}")


def ensure_output_dir():
    """Garante que o diretório de saída existe."""
    with file_lock:
        if not os.path.exists(OUTPUT_DIR):
            os.makedirs(OUTPUT_DIR)


def handle_client(conn, addr, client_id):
    """
    Trata a conexão de um cliente em uma thread separada.
    Mantém a conexão aberta para múltiplas requisições.
    """
    print(f"[Cliente {client_id}] Conectado: {addr}")
    
    try:
        while True:
            # Aguarda o próximo comando do cliente
            try:
                req = conn.recv(1024).decode().strip()
            except ConnectionResetError:
                print(f"[Cliente {client_id}] Conexão resetada pelo cliente")
                break
            
            if not req:
                # Cliente fechou a conexão
                print(f"[Cliente {client_id}] Desconectado")
                break
            
            print(f"[Cliente {client_id}] Recebido: {req}")
            
            # Comando para encerrar a conexão
            if req.upper() == "EXIT":
                conn.sendall(b"BYE")
                print(f"[Cliente {client_id}] Solicitou encerramento")
                break
            
            if not req.startswith("CONVERT"):
                conn.sendall(b"ERROR comando_invalido")
                continue
            
            parts = req.split()
            if len(parts) != 4:
                conn.sendall(b"ERROR formato_comando_invalido")
                continue
            
            _, src, dst, filename = parts
            
            # Remove o ponto se o usuário digitou .txt .pdf
            src = src.lstrip(".")
            dst = dst.lstrip(".")
            
            if (src, dst) not in SUPPORTED:
                conn.sendall(b"ERROR formato_nao_suportado")
                continue
            
            conn.sendall(b"OK")
            
            # Recebe tamanho do arquivo
            raw_size = conn.recv(8)
            if len(raw_size) < 8:
                print(f"[Cliente {client_id}] Erro ao receber tamanho do arquivo")
                break
            
            (size,) = struct.unpack("!Q", raw_size)
            
            # Recebe o conteúdo do arquivo
            content = b""
            while len(content) < size:
                chunk = conn.recv(min(4096, size - len(content)))
                if not chunk:
                    break
                content += chunk
            
            if len(content) != size:
                conn.sendall(struct.pack("!Q", 0))  # Sinaliza erro
                continue
            
            # Gera nomes únicos para arquivos temporários usando UUID
            unique_id = uuid.uuid4().hex[:8]
            input_path = f"temp_{unique_id}_{filename}"
            
            # Nome do arquivo de saída (sem extensão original, adiciona nova)
            base_name = os.path.splitext(filename)[0]
            output_filename = f"{base_name}_{unique_id}.{dst}"
            output_path = os.path.join(OUTPUT_DIR, output_filename)
            
            try:
                # Garante que o diretório de saída existe
                ensure_output_dir()
                
                # Salva o arquivo temporário
                with open(input_path, "wb") as f:
                    f.write(content)
                
                # Realiza a conversão
                convert_file(input_path, output_path, src, dst)
                
                # Lê o arquivo convertido
                with open(output_path, "rb") as f:
                    result_data = f.read()
                
                # Envia o tamanho e o conteúdo do arquivo convertido
                conn.sendall(struct.pack("!Q", len(result_data)))
                conn.sendall(result_data)
                
                # Envia o nome do arquivo salvo no servidor
                name_bytes = output_filename.encode()
                conn.sendall(struct.pack("!H", len(name_bytes)))
                conn.sendall(name_bytes)
                
                print(f"[Cliente {client_id}] Conversão concluída: {filename} -> {output_filename}")
                
            except Exception as e:
                print(f"[Cliente {client_id}] Erro na conversão: {e}")
                conn.sendall(struct.pack("!Q", 0))
            finally:
                # Remove apenas o arquivo temporário de entrada
                if os.path.exists(input_path):
                    os.remove(input_path)
                    
    except Exception as e:
        print(f"[Cliente {client_id}] Erro inesperado: {e}")
    finally:
        conn.close()
        print(f"[Cliente {client_id}] Conexão encerrada")

def main():
    global client_counter
    
    # Garante que o diretório de saída existe
    ensure_output_dir()
    
    server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    # Permite reutilizar a porta imediatamente após o servidor ser fechado
    server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    server.bind(("0.0.0.0", 5050))
    server.listen(5)  # Fila de até 5 conexões pendentes

    print("=" * 50)
    print("SERVIDOR DE CONVERSÃO DE ARQUIVOS")
    print("=" * 50)
    print(f"Aguardando conexões na porta 5050...")
    print(f"Conversões suportadas: {SUPPORTED}")
    print(f"Arquivos convertidos serão salvos em: ./{OUTPUT_DIR}/")
    print("=" * 50)

    try:
        while True:
            conn, addr = server.accept()
            
            # Incrementa o contador de clientes de forma thread-safe
            with counter_lock:
                client_counter += 1
                current_id = client_counter
            
            # Cria uma nova thread para cada cliente
            client_thread = threading.Thread(
                target=handle_client,
                args=(conn, addr, current_id),
                daemon=True  # Thread daemon para encerrar com o programa principal
            )
            client_thread.start()
            print(f"[Servidor] Thread iniciada para cliente {current_id}. Threads ativas: {threading.active_count() - 1}")
            
    except KeyboardInterrupt:
        print("\n[Servidor] Encerrando...")
    finally:
        server.close()
        print("[Servidor] Servidor encerrado.")

if __name__ == "__main__":
    main()
